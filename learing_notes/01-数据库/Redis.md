##### Redis

基于C语言编写，内存中的数据库，读写速度很快，一般用来做缓存，分布式锁，也可以用来设计消息队列，同时支持事务、持久化、Lua脚本、多种集群方案

单线程多路IO复用模型  6.0版本引入多线程

高性能键值缓存服务器memcached

##### 数据类型

基本数据类型：String、 list、set、zset、hash

三种特殊数据结构：位图、计数器、地理空间

##### 持久化方式

持久化：把内存中的数据写入磁盘。

RDB快照方式和AOF追加模式

RDB（Redis DataBase）:时间点存储，通过创建快照来获取存储在内存里面的数据在某个时间点上的副本。在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建相同数据的服务器副本。

AOF（Append Only File）:将被执行的写命令写到AOF文件的末尾

比较：

AOF文件比RDB更新频率高，优先使用AOF还原数据

AOF比RDB更安全更大

RDB性能比AOF好

如果两个都配置了优先加载AOF

##### Redis数据过期删除策略

惰性删除：只会在取出key的时候才对数据进行过期检查，对CPU友好，造成太多的过期key没被删除

定期删除：每隔一段时间抽取一批key执行删除过期key的操作，redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，对内存友好

采用两者结合的方式

##### Redis数据淘汰策略

volatile-LRU:从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

volatile-random:从已设置过期时间的数据集中随机选择数据淘汰

volatile-TTL:从已设置过期时间的数据集中挑选要过期的数据淘汰

allkeys-LRU:当内存不足以容纳新写入的数据时，在键空间移除最近最少使用的key（最常用）

allkeys_random:

##### 缓存穿透、缓存击穿、缓存雪崩

缓存穿透：一些恶意的请求故意查询不存在的key，而且请求量很大，对后端系统造成很大的压力

缓存击穿：对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个key有大量的并发请求，这些请求发现缓存过期一般都会从后端DB加载数据回设到缓存，大并发的请求可能会瞬间把DB压垮。

缓存雪崩：当缓存服务器重启或者大量缓存集中在某一时间段失效，失效的时候，会给后端系统带来很大的压力，导致系统崩溃。

##### Redis分布式锁

分布锁满足两个条件：

1.加有效时间的锁

2.高性能解锁

采用setnx(set if not exist)获取锁、setex（set expire value）设置锁超时时间。



包重传，清空缓存

