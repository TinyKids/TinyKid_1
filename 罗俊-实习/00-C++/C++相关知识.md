### C++相关知识

#### C++编译过程:

预处理：去除宏定义、条件编译、预编译指令（#include）去除注释、生成行号、生成文件名标识、保留所有#pragma编译器指令

编译：将预处理完的文件进行词法、语法、语义分析及优化生成汇编代码

汇编：将汇编代码进行翻译，生成机器指令，生成可重定位目标二进制文件，字节编码是机器指令。

链接：通过链接器将一个个目标文件（可能还有库文件）链接一起生成一个完整的可执行程序。

运行：

#### C语言变量声明内存分配

栈区：程序运行时由编译器分配和释放，大小由操作系统和编译器决定，存放函数指令地址，函数参数、局部变量的值

堆区：内存开辟一块存储区域，程序员分配和释放，

全局区（静态区）：编译器编译时即分配内存，全局变量和静态变量放一起，分初始化和未初始化两个区域，.bss和.data,程序结束后由系统释放

文字常量区：存放常量字符串

程序代码区：存放函数体二进制代码

#### 堆和栈对比

栈：连续的内存区域，高地址向低地址扩展，栈顶的地址和栈的最大容量是系统预先规定好的，编译后栈的大小是个常数，系统自动分配，速度较快，程序员无法控制。

堆：非连续内存区域，低地址向高地址扩展，堆大小受限于操作系统的有效虚拟内存，堆空间比较灵活也比较大。

栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。

堆则是C/C++函数库提供的，它的机制是很复杂的

堆上分配对象数组时，使用new只能调用默认的构造函数

#### extern

extern用于修饰变量或者函数，表示修饰对象的定义在别的文件中，提示编译器遇到此变量时在别的模块寻找定义。

extern C

告诉编译器，保持函参数类型和函数名连接在一起，以此区分不同的函数。

#### 顶层const/底层const

指针本身是常量为顶层const，指向对象为常量为底层const

int* const  为顶层const

const int*为底层const 

常量的底层const不能赋值给非常量的底层const

end()返回的是尾后迭代器，所以不能解引用

#### 常量

常量分为编译时间常量（如常量表达式）和运行时间常量

常量引用本身也是引用，引用在汇编层为常量指针

#### 声明和定义的区别

1.声明是将一个符号引入到一个作用域，定义提供了一个实体在程序中的唯一描述

2.编译期间只检测程序语法和函数或者变量的声明，在链接期间，在所有目标文件中查找函数的实现。

#### 类型转换

static_cast:基类派生类之间转换，算术类型转换，不包含底层const都可以使用

dynamic_cast：基类派生类之间的转换，深层继承中效率很低（解决的对策：基类也声明派生类的函数，不予以实现即可，使用多态方式）

const_cast：解除底层const属性

reinterpret_cast：将任何类型指针转换成任何其他类型指针

static_cast和dynamic_cast区别：子类到父类都安全，父类到子类，后者会进行类型检查，出错返回空指针；static_cast不会类型检查，返回的是个错误的子类指针

#### 静态全局变量和全局变量

非静态全局变量在各个源文件中都是有效的



**为了抑制隐式转换，可以将构造函数声明为explicit,只加在声明的地方，定义的地方不加；此时用该构造函数初始化时，不能用=拷贝初始化，只能直接初始化**

**友元声明仅仅说明访问权限，不属于函数声明，所以在使用这个函数时还需要另写声明，此时前面不加friend**

**mutable修饰的可变数据成员即使在常量成员函数里面也可以修改值**

##### 内联函数（编译时展开）、构造函数、静态成员函数不可以定义为虚函数

const修饰符用于表示函数不能修改成员变量的值

const不能修饰static函数，因为const修饰的是this指针，而静态函数中没有this指针。

#### 移动构造函数

所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。



#### 左值右值

左值：表达式结束依然存在的持久化对象

右值：表达式结束就不再存在的临时对象

所有具名变量都是左值，右值不具名

区分：对表达式取地址，能取地址为左值，不能则为右值

template<typename T>

void func(T &&t){

 func1(forward(forward<T>(t)));}

#### 隐式接口和编译器多态

1. 类是显示接口，中心是函数签名式，多态是运行时多态；
2. 模板是隐式接口，基础是函数有效表达式，多态是编译时多态；

#### typename的双重意义

模板参数类型声明使用class和typename效果相同；

template<class T>和template<typename T>

模板内名称依赖于某个模板参数时，称为从属名称，反之为非从属名称

使用成员函数模板定义的构造函数称为泛化构造函数

#### placement_new

operator new 接收了除了size_t以外的参数，除了分配大小，称为placement new

特定版本，第二个指针指向对象被构造的地址

#### emplace_back()和push_back()

push_back()是创建这个元素，然后将元素拷贝或者移动到容器中

emplace_back()直接再容器尾部创建这个元素，省去了拷贝或者移动元素的过程





