**智能指针：**

unique_ptr:unique_ptr的核心特点就如它的名字一样，它**拥有对持有对象的唯一所有权**，即两个unique_ptr不能同时指向同一个对象。

- unique_ptr不能被复制到另外一个unique_ptr。

- unique_ptr所持有的对象只能通过转移语义将所有权转移到另外一个unique_ptr。
- unique_ptr中唯一的数据成员就是原生指针和析构器的pair

shared_ptr:通过计数方式多个share_ptr可以共享一段内存，当计数为0的时候，所管理内存会被删除，

主要问题：1.环形引用2.不是多线程安全的3.不能用于保存指向动态分配的数组

weak_ptr:观察shared_ptr管理的内存对象，只观察但不拥有。成员函数lock返回shared_ptr对象，若对应内存已经删除，则shared_ptr对象==nullptr，weak_ptr对象可以拷贝构造，拷贝构造出来的对象和原对象观察的是同一段内存。可以避免因shared_ptr的循环引用而引起的内存泄露。



**使用场景**

unique_ptr:一个对象在对象或方法内部使用时优先使用unique_ptr

shared_ptr:这个对象需要被多个Class同时使用的时候。

使用new的方式创建shared_ptr会导致出现两次内存申请，而std::make_shared在内部实现时只会申请一个内存。因此建议后续均使用std::make_shared。

**为什么项目中选择智能指针，而不是一般的指针？**

1.首先引入智能指针能够便于开发者更好地管理堆区的资源，防止内存泄漏。

2.当项目中代码量增加时，逻辑多了以后（比如说顶层逻辑中引用了一个指针，而在业务逻辑中将其删除了），随意地delete原生指针很容易引入bug，指针问题难以定位。

3.项目中找不到确定的位置来删除对象，或者有时候无法确定要删除该对象的对象时，通过使用智能指针，利用其通过生命周期自动析构的特性，是个很好的解决方案。

4.多线程下对象的析构问题，锁机制很难解决。对象一般是被多个线程使用。假如某个线程想要释放这个对象，但另外一个线程还在使用这个对象，可能会出现野指针问题。就算释放对象的线程将对象释放后将指针置为nullptr，但仍然可能在多线程下在指针置空前被另外一个线程取得地址并使用。



智能指针本身是一个栈上分配的对象，根据栈上分配的特性，在离开作用域后，会自动调用其析构方法。

多线程下对象析构解决办法：

有了智能指针之后，我们就可以使用智能指针解决多线程下的对象析构问题。我们使用shared_ptr管理ReportClass。并将weak_ptr传给子线程，子线程会判断外部的ReportClass是否已经被销毁，如果没有被销毁会通过weak_ptr换取shared_ptr，否则线程退出。解决了外部对象销毁，内部线程使用外部对象的野指针的问题。





C++new/delete 和malloc/free区别

1.new为C++关键字，malloc只是c库的库函数

2.malloc分配内存需要传入分配数据类型的字节数，C++中的new是直接通过指定类型来进行分配内存，这样更加直接和简洁。

3.C++的关键字new主要是为分配对象内存空间设计的，malloc等库函数仅仅只是单纯的内存分配，new动态分配对象空间还会调用构造函数。





在C++中, 如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象。

阻止这种用法的对策是使用explicit关键字，取消隐式转换

